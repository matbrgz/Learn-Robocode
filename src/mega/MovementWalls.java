package mega;

import robocode.*;
import robocode.util.Utils;

/**
 * Implements a "Walls" movement strategy.
 * This strategy attempts to keep the robot moving along the perimeter of the battlefield,
 * bouncing off walls. This can be effective for evading bullets and maintaining distance
 * from opponents, especially in melee scenarios or when trying to circle.
 * 
 * The robot will primarily move forward or backward along a wall. When it hits a wall,
 * it changes its heading to continue moving along the wall, or reverses direction.
 * 
 * @author Gates
 */
public class MovementWalls extends Movement {

    /**
     * Flag to determine if the robot is currently moving forward or backward.
     * {@code true} for moving ahead, {@code false} for moving back.
     */
    private boolean _movingForward;

    /**
     * Constructs a new MovementWalls component with the given battle {@link State}.
     * Initializes the robot to move forward initially.
     * @param state The shared {@link State} object for the robot.
     */
    public MovementWalls(State state) {
        super(state);
        this._movingForward = true; // Start by moving forward.
    }

    /**
     * Executes the Walls movement strategy for one turn.
     * The robot attempts to move along the walls. If it detects it's hitting
     * or very close to a wall, it will turn its body to continue moving
     * parallel to the wall, or reverse direction if necessary.
     * This method sets the desired {@code speed} and {@code rotation} for the robot.
     */
    @Override
    public void execute() {
        AdvancedRobot owner = this.state.owner;

        // Define a buffer zone from the walls. If the robot is within this zone, it's considered "near a wall".
        // Robocode robots are 36x36 pixels.
        double wallBuffer = 30; 

        boolean nearWall = (owner.getX() <= wallBuffer || owner.getX() >= owner.getBattleFieldWidth() - wallBuffer ||
                            owner.getY() <= wallBuffer || owner.getY() >= owner.getBattleFieldHeight() - wallBuffer);

        if (nearWall) {
            // If near a wall, try to turn parallel to it.
            // This is a basic wall-hugging logic. More advanced strategies would use
            // vectors or prediction to find an optimal wall-hugging path.
            double desiredHeading = owner.getHeadingRadians(); // Start with current heading

            if (owner.getX() <= wallBuffer) { // Near left wall
                desiredHeading = Math.PI / 2; // Aim to move up (90 degrees)
            } else if (owner.getX() >= owner.getBattleFieldWidth() - wallBuffer) { // Near right wall
                desiredHeading = 3 * Math.PI / 2; // Aim to move down (270 degrees)
            } else if (owner.getY() <= wallBuffer) { // Near bottom wall
                desiredHeading = 0; // Aim to move right (0 degrees)
            } else if (owner.getY() >= owner.getBattleFieldHeight() - wallBuffer) { // Near top wall
                desiredHeading = Math.PI; // Aim to move left (180 degrees)
            }

            // Calculate the relative turn angle to align with the desired heading.
            this.rotation = Utils.normalRelativeAngle(desiredHeading - owner.getHeadingRadians());
            this.speed = (this._movingForward ? 100 : -100); // Keep moving along the wall
            
        } else {
            // If not near a wall, simply keep moving in the current direction and rotation.
            // This might cause the robot to drift towards the center until it hits another wall.
            this.speed = (this._movingForward ? 100 : -100);
            this.rotation = 0; // No additional turning
        }
    }

    /**
     * Overrides the {@code onHitWall} event to reverse the robot's primary movement direction.
     * This helps the robot to bounce off walls and continue moving along the perimeter.
     * @param e The HitWallEvent object generated by the collision with a wall.
     */
    public void onHitWall(HitWallEvent e) {
        // Reverse direction when a wall is hit.
        this._movingForward = !this._movingForward;
        // Also, force a small turn to help it get off the wall more smoothly,
        // although the execute method should handle most of the turning.
        this.rotation = Utils.normalRelativeAngle(Math.PI / 2); // Turn 90 degrees relative
    }
}